<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Ley de Hooke y Sistemas de Muelles con Energías</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden; 
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #d1d5db;
            cursor: default;
        }
        .control-group {
            background-color: #1f2937;
            border: 1px solid #374151;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: #9ca3af;
        }
        .value-display {
            font-weight: 600;
            color: #e5e7eb;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: #374151;
            border-radius: 3px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        .info-box {
            background-color: rgba(31, 41, 55, 0.8);
            padding: 6px 10px;
            border-radius: 6px;
            color: white;
            font-size: 0.75rem;
            line-height: 1.2;
            border: 1px solid #4b5563;
            margin-bottom: 1rem;
            text-align: center;
        }
        .chronometer-box {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(31, 41, 55, 0.8);
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #4b5563;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 20;
        }
        .main-container {
            display: flex;
            flex-direction: row;
            height: 100vh;
            position: relative; 
        }
        .simulation-column {
            flex-grow: 1;
            position: relative;
        }
        .controls-column {
            width: 384px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            background-color: #1f2937;
            border-left: 1px solid #374151;
        }
        .controls-scroll-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem;
        }
        #simulation-canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: default;
        }
        #simulation-canvas.grabbing { cursor: grabbing; }
        #simulation-canvas.grab-cursor { cursor: grab; }
        #simulation-canvas.move-cursor { cursor: move; }
        
        #energy-chart-overlay {
            position: relative;
            width: 100%;
            height: 200px;
            background-color: rgba(31, 41, 55, 0.85);
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            padding: 0.75rem;
            z-index: 10;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 1rem;
        }
        #energy-chart-overlay.hidden {
            display: none;
        }
        #energy-chart-overlay .chart-header {
            margin-bottom: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: #e5e7eb;
            text-align: center;
            padding: 4px;
            cursor: default;
            user-select: none;
        }
        #energy-chart-container {
            flex-grow: 1;
            position: relative;
        }
        .attribution {
            padding: 1rem 1.5rem;
            text-align: center;
            font-size: 0.875rem;
            color: #6b7280;
        }
        #start-pause-btn, #reset-simulation-btn {
            font-size: 0.8rem;
            padding: 0.4rem 0.8rem;
        }

        .mobile-only { display: none; }
        .desktop-only { display: inline; }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: row;
                height: 100%;
            }
            .simulation-column, .controls-column {
                width: 50%;
                flex-shrink: 0;
            }
            .controls-column {
                border-top: none;
                border-left: 1px solid #374151;
            }
            .controls-scroll-area {
                padding: 1rem;
            }
            .attribution {
                padding: 0.5rem 1rem;
            }
            .control-label, .value-display, label.flex.items-center span.ml-2 {
                font-size: 0.75rem;
            }
            .control-group h3 {
                font-size: 0.9rem;
            }
            #sticky-controls {
                position: -webkit-sticky;
                position: sticky;
                top: 0;
                z-index: 10;
                background-color: #1f2937; 
                padding-top: 1rem;
            }
            #energy-chart-overlay .chart-header {
                font-size: 0.9rem;
            }
            #info-display-canvas { display: none; }
            #info-display-panel { display: block; }
            
            .mobile-only { display: inline; }
            .desktop-only { display: none; }
        }

        @media (min-width: 769px) {
            #start-pause-btn, #reset-simulation-btn {
                font-size: 0.9rem;
                padding: 0.5rem 1rem;
            }
            .info-box {
                position: absolute;
                top: 10px;
                left: 10px;
                pointer-events: none;
                z-index: 20;
                margin-bottom: 0;
                text-align: left;
            }
            #info-display-panel { display: none; }
            #info-display-canvas { display: block; }

            #energy-chart-overlay {
                position: absolute;
                width: 420px;
                height: 220px;
                bottom: 15px;
                left: 15px;
                margin-top: 0;
                z-index: 30;
            }
            #energy-chart-overlay .chart-header {
                cursor: move;
            }
        }
    </style>
</head>
<body>

    <div class="main-container">
        <!-- Columna de Simulación -->
        <div class="simulation-column">
            <canvas id="simulation-canvas"></canvas>
            <div id="info-display-canvas" class="info-box"></div>
            <div id="chronometer-container" class="chronometer-box hidden">
                <div id="chronometer-time" class="text-white text-md font-semibold">0.0s</div>
                <button id="chrono-pause-play-btn" title="Pausar/Reanudar">
                    <svg id="icon-play" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5"><path d="M8 6.82v10.36c0 .79.87 1.27 1.54.84l8.14-5.18c.62-.39.62-1.29 0-1.69L9.54 5.98C8.87 5.55 8 6.03 8 6.82z"></path></svg>
                    <svg id="icon-pause" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 hidden"><path d="M6 5h2v14H6V5zm10 0h2v14h-2V5z"></path></svg>
                </button>
                <button id="chrono-reset-btn" title="Reiniciar Cronómetro">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5"><path d="M12 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm-1-8v4h2v-4h-2z"></path></svg>
                </button>
            </div>
        </div>

        <!-- Columna de Controles -->
        <div class="controls-column">
            <div class="controls-scroll-area">
                <div id="sticky-controls">
                    <div class="control-group">
                        <label class="control-label" for="sim-mode">Modo de Simulación</label>
                        <select id="sim-mode" class="w-full mt-2 bg-gray-700 border border-gray-600 rounded-md p-2 text-white">
                            <option value="1">Un Muelle</option>
                            <option value="2">Dos Muelles</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <h3 class="text-lg font-semibold mb-2 text-white">Controles</h3>
                        <button id="start-pause-btn" class="w-full mt-2 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors">
                            Empezar
                        </button>
                        <button id="reset-simulation-btn" class="w-full mt-2 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors">
                            Reiniciar
                        </button>
                    </div>
                </div>
                
                <div id="info-display-panel" class="info-box"></div>

                <div id="springs-controls-container">
                </div>
                
                <div id="global-controls-container">
                </div>

                <div class="control-group">
                    <h3 class="text-lg font-semibold mb-2 text-white">Visualización</h3>
                    <div class="space-y-2">
                        <label class="flex items-center"><input type="checkbox" id="show-forces" class="form-checkbox" checked> <span class="ml-2">Vectores de Fuerza</span></label>
                        <label class="flex items-center"><input type="checkbox" id="show-va-vectors" class="form-checkbox"> <span class="ml-2">Vectores v/a</span></label>
                        <label class="flex items-center"><input type="checkbox" id="show-natural-length" class="form-checkbox"> <span class="ml-2">Longitud natural</span></label>
                        <label class="flex items-center"><input type="checkbox" id="show-equilibrium-pos" class="form-checkbox" checked> <span class="ml-2">Posición de equilibrio</span></label>
                        <label class="flex items-center"><input type="checkbox" id="show-movable-ref" class="form-checkbox"> <span class="ml-2">Referencia móvil</span></label>
                        <label class="flex items-center"><input type="checkbox" id="show-ruler" class="form-checkbox"> <span class="ml-2">Regla</span></label>
                        <label class="flex items-center"><input type="checkbox" id="show-chronometer" class="form-checkbox"> <span class="ml-2">Cronómetro</span></label>
                        <label class="flex items-center"><input type="checkbox" id="show-energy-graph" class="form-checkbox"> <span class="ml-2">Gráfica de Energías</span></label>
                    </div>
                </div>
                <div id="energy-chart-overlay" class="hidden">
                    <h3 class="chart-header">Gráfica de Energías (J)</h3>
                    <div id="energy-chart-container">
                        <canvas id="energy-chart"></canvas>
                    </div>
                </div>
                <div class="attribution">
                    <a href="https://aulaquest.com" target="_blank" rel="noopener noreferrer">Simulación por aulaquest.com</a>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- SETUP ---
        const canvas = document.getElementById('simulation-canvas');
        const ctx = canvas.getContext('2d');
        const energyChartCanvas = document.getElementById('energy-chart');
        let energyChart;

        let parent = canvas.parentElement;
        let width, height;
        const dpr = window.devicePixelRatio || 1;

        function resizeCanvas() {
            parent = canvas.parentElement;
            width = parent.clientWidth;
            height = parent.clientHeight;
            
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;

            updateScale();
        }
        
        window.addEventListener('resize', resizeCanvas);

        // --- STATE MANAGEMENT ---
        const BASE_PIXELS_PER_METER = 250;
        const START_Y = 50;

        const simState = {
            mode: 1, 
            gravity: 9.81,
            simulationState: 'initial',
            showForces: true,
            showVelocityAccelVectors: false,
            showNaturalLength: false,
            showEquilibrium: true,
            showMovableRef: false,
            showRuler: false,
            showChronometer: false,
            showEnergyGraph: false,
            movableRefY: 300,
            isDraggingRef: false,
            ruler: { x: 100, y: 80, width: 60, height: 400, isDragging: false, offsetX: 0, offsetY: 0 },
            chronometerTime: 0,
            chronometerManualPause: false,
            springs: []
        };

        function createSpringState(defaults = {}) {
            return {
                mass: defaults.mass || 1.0,
                k: defaults.k || 50,
                l0: defaults.l0 || 0.5,
                damping: defaults.damping || 0.005,
                position: 0,
                velocity: 0,
                acceleration: 0,
                isDraggingMass: false,
                massDrag: { startY: 0, startPos: 0 },
                oscillationCount: 0,
                lastPosSign: 0,
                energies: { kinetic: 0, potentialG: 0, potentialE: 0, total: 0 },
                potentialGRefY: 0,
            };
        }

        // --- DOM ELEMENTS ---
        let startPauseBtn, resetSimulationBtn, chronoContainer, chronoTimeEl, 
            chronoPausePlayBtn, chronoResetBtn, iconPause, iconPlay, energyChartOverlay,
            springsControlsContainer, simModeSelect, globalControlsContainer;
        
        function generateSpringControls() {
            springsControlsContainer.innerHTML = '';
            globalControlsContainer.innerHTML = '';
            
            if (simState.mode === 1) {
                const spring = simState.springs[0];
                const controlHtml = `
                    <div class="control-group">
                        <h3 class="text-lg font-semibold mb-2 text-white">Muelle 1</h3>
                        <div class="flex items-center justify-between">
                            <label class="control-label" for="mass0">Masa (m1) <span id="mass0-value" class="value-display">${spring.mass.toFixed(1)} kg</span></label>
                        </div>
                        <input type="range" id="mass0" min="0.1" max="5" step="0.1" value="${spring.mass}" class="w-full mt-2">
                        
                        <div class="flex items-center justify-between mt-4">
                            <label class="control-label" for="k0">Constante (k1) <span id="k0-value" class="value-display">${spring.k.toFixed(0)} N/m</span></label>
                        </div>
                        <input type="range" id="k0" min="10" max="100" step="1" value="${spring.k}" class="w-full mt-2">
                    </div>
                `;
                springsControlsContainer.innerHTML = controlHtml;

                const globalControlsHtml = `
                    <div class="control-group">
                        <label class="control-label" for="gravity">Planeta</label>
                        <select id="gravity" class="w-full mt-2 bg-gray-700 border border-gray-600 rounded-md p-2 text-white">
                            <option value="9.81" ${simState.gravity === 9.81 ? 'selected' : ''}>Tierra</option>
                            <option value="1.62" ${simState.gravity === 1.62 ? 'selected' : ''}>Luna</option>
                            <option value="3.71" ${simState.gravity === 3.71 ? 'selected' : ''}>Marte</option>
                            <option value="24.79" ${simState.gravity === 24.79 ? 'selected' : ''}>Júpiter</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label class="control-label" for="damping0">Amortiguamiento <span id="damping0-value" class="value-display">Bajo</span></label>
                        <input type="range" id="damping0" min="0" max="50" step="1" value="${spring.damping * 1000}" class="w-full mt-2">
                    </div>
                `;
                globalControlsContainer.innerHTML = globalControlsHtml;

            } else { // Modo 2 muelles
                for (let i = 0; i < simState.mode; i++) {
                    const spring = simState.springs[i];
                    const controlHtml = `
                        <div class="control-group">
                            <h3 class="text-lg font-semibold mb-2 text-white">Muelle ${i + 1}</h3>
                            <div class="flex items-center justify-between">
                                <label class="control-label" for="mass${i}">Masa (m${i+1}) <span id="mass${i}-value" class="value-display">${spring.mass.toFixed(1)} kg</span></label>
                            </div>
                            <input type="range" id="mass${i}" min="0.1" max="5" step="0.1" value="${spring.mass}" class="w-full mt-2">
                            
                            <div class="flex items-center justify-between mt-4">
                                <label class="control-label" for="k${i}">Constante (k${i+1}) <span id="k${i}-value" class="value-display">${spring.k.toFixed(0)} N/m</span></label>
                            </div>
                            <input type="range" id="k${i}" min="10" max="100" step="1" value="${spring.k}" class="w-full mt-2">

                            <div class="flex items-center justify-between mt-4">
                                <label class="control-label" for="damping${i}">
                                    <span class="desktop-only">Amortiguamiento ${i+1}</span>
                                    <span class="mobile-only">Amort. ${i+1}</span>
                                    <span id="damping${i}-value" class="value-display">Bajo</span>
                                </label>
                            </div>
                            <input type="range" id="damping${i}" min="0" max="50" step="1" value="${spring.damping * 1000}" class="w-full mt-2">
                        </div>
                    `;
                    springsControlsContainer.innerHTML += controlHtml;
                }
                 const globalControlsHtml = `
                    <div class="control-group">
                        <label class="control-label" for="gravity">Planeta</label>
                        <select id="gravity" class="w-full mt-2 bg-gray-700 border border-gray-600 rounded-md p-2 text-white">
                            <option value="9.81" ${simState.gravity === 9.81 ? 'selected' : ''}>Tierra</option>
                            <option value="1.62" ${simState.gravity === 1.62 ? 'selected' : ''}>Luna</option>
                            <option value="3.71" ${simState.gravity === 3.71 ? 'selected' : ''}>Marte</option>
                            <option value="24.79" ${simState.gravity === 24.79 ? 'selected' : ''}>Júpiter</option>
                        </select>
                    </div>
                `;
                globalControlsContainer.innerHTML = globalControlsHtml;
            }
            addControlListeners();
        }

        function addControlListeners() {
            document.getElementById('gravity').addEventListener('input', (e) => { simState.gravity = parseFloat(e.target.value); resetSimulation(); });

            for (let i = 0; i < simState.mode; i++) {
                document.getElementById(`mass${i}`).addEventListener('input', (e) => {
                    simState.springs[i].mass = parseFloat(e.target.value);
                    document.getElementById(`mass${i}-value`).textContent = `${simState.springs[i].mass.toFixed(1)} kg`;
                    resetSimulation();
                });
                document.getElementById(`k${i}`).addEventListener('input', (e) => {
                    simState.springs[i].k = parseFloat(e.target.value);
                    document.getElementById(`k${i}-value`).textContent = `${simState.springs[i].k.toFixed(0)} N/m`;
                    resetSimulation();
                });
                
                const dampingSlider = document.getElementById(`damping${i}`);
                if (dampingSlider) {
                    dampingSlider.addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        simState.springs[i].damping = val / 1000;
                        const dampingDisplay = document.getElementById(`damping${i}-value`);
                        if (val === 0) dampingDisplay.textContent = 'Cero';
                        else if (val < 10) dampingDisplay.textContent = 'Bajo';
                        else if (val < 30) dampingDisplay.textContent = 'Medio';
                        else dampingDisplay.textContent = 'Alto';
                    });
                    const initialVal = parseFloat(dampingSlider.value);
                    const initialDisplay = document.getElementById(`damping${i}-value`);
                    if (initialVal === 0) initialDisplay.textContent = 'Cero';
                    else if (initialVal < 10) initialDisplay.textContent = 'Bajo';
                    else if (initialVal < 30) initialDisplay.textContent = 'Medio';
                    else initialDisplay.textContent = 'Alto';
                }
            }
        }

        function initEnergyChart() {
            const chartCtx = energyChartCanvas.getContext('2d');
            Chart.defaults.color = '#d1d5db';
            Chart.defaults.font.family = "'Inter', sans-serif";
            
            const chartConfig = {
                type: 'bar',
                data: {},
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { grid: { color: '#374151' }, ticks: { color: '#9ca3af', font: { size: 10 } } },
                        y: { grid: { display: false }, ticks: { color: '#d1d5db', font: { size: 11 } } }
                    },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { font: { size: 10 } } },
                        tooltip: { animation: false }
                    },
                    animation: false,
                }
            };

            if (energyChart) {
                energyChart.destroy();
            }
            energyChart = new Chart(chartCtx, chartConfig);
            updateChartDataConfig();
        }

        function updateChartDataConfig() {
            if (!energyChart) return;

            if (simState.mode === 1) {
                energyChart.config.options.indexAxis = 'y';
                energyChart.config.options.plugins.legend.display = false;
                energyChart.config.data = {
                    labels: ['Cinética', 'Pot. Elástica', 'Pot. Gravit.', 'Total'],
                    datasets: [{
                        label: 'Energía (J)',
                        data: [0, 0, 0, 0],
                        backgroundColor: ['rgba(59, 130, 246, 0.7)', 'rgba(249, 115, 22, 0.7)', 'rgba(34, 197, 94, 0.7)', 'rgba(217, 70, 239, 0.7)'],
                        borderColor: ['rgba(59, 130, 246, 1)', 'rgba(249, 115, 22, 1)', 'rgba(34, 197, 94, 1)', 'rgba(217, 70, 239, 1)'],
                        borderWidth: 1
                    }]
                };
            } else { 
                energyChart.config.options.indexAxis = 'x';
                energyChart.config.options.plugins.legend.display = true;
                energyChart.config.data = {
                    labels: ['Cinética', 'Pot. Elástica', 'Pot. Gravit.', 'Total'],
                    datasets: [
                        { label: 'Muelle 1', data: [0, 0, 0, 0], backgroundColor: 'rgba(59, 130, 246, 0.7)', borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 1 },
                        { label: 'Muelle 2', data: [0, 0, 0, 0], backgroundColor: 'rgba(249, 115, 22, 0.7)', borderColor: 'rgba(249, 115, 22, 1)', borderWidth: 1 }
                    ]
                };
            }
            energyChart.update();
        }
        
        function getEquilibriumPosition(spring) {
            return spring.l0 + (spring.mass * simState.gravity) / spring.k;
        }

        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            startPauseBtn.addEventListener('click', handleStartPause);
            resetSimulationBtn.addEventListener('click', fullReset);
            simModeSelect.addEventListener('change', (e) => {
                simState.mode = parseInt(e.target.value);
                fullReset();
            });

            document.getElementById('show-forces').addEventListener('change', (e) => simState.showForces = e.target.checked);
            document.getElementById('show-va-vectors').addEventListener('change', (e) => simState.showVelocityAccelVectors = e.target.checked);
            document.getElementById('show-natural-length').addEventListener('change', (e) => simState.showNaturalLength = e.target.checked);
            document.getElementById('show-equilibrium-pos').addEventListener('change', (e) => simState.showEquilibrium = e.target.checked);
            document.getElementById('show-movable-ref').addEventListener('change', (e) => simState.showMovableRef = e.target.checked);
            document.getElementById('show-ruler').addEventListener('change', (e) => simState.showRuler = e.target.checked);
            document.getElementById('show-chronometer').addEventListener('change', (e) => {
                simState.showChronometer = e.target.checked;
                chronoContainer.classList.toggle('hidden', !e.target.checked);
            });
            document.getElementById('show-energy-graph').addEventListener('change', (e) => {
                 simState.showEnergyGraph = e.target.checked;
                 energyChartOverlay.classList.toggle('hidden', !e.target.checked);
            });
            
            chronoPausePlayBtn.addEventListener('click', toggleChronometer);
            chronoResetBtn.addEventListener('click', resetChronometer);

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
            canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
            canvas.addEventListener('touchend', handleMouseUp);

            setupChartDrag();
        }
        
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
        }

        function handleMouseDown(e) {
            e.preventDefault();
            const { x, y } = getEventPos(e);
            
            simState.springs.forEach((s, i) => {
                const massSize = 25 + Math.sqrt(s.mass) * 12;
                const massX_px = (width / (simState.mode + 1)) * (i + 1);
                const massY_px = START_Y + s.position * simState.pixelsPerMeter;
                
                if (x > massX_px - massSize && x < massX_px + massSize && y > massY_px && y < massY_px + massSize) {
                    s.isDraggingMass = true;
                    s.massDrag.startY = y;
                    s.massDrag.startPos = s.position;
                    canvas.classList.add('grabbing');
                    return;
                }
            });

            if (simState.showMovableRef && Math.abs(y - simState.movableRefY) < 15) {
                simState.isDraggingRef = true;
                canvas.classList.add('grabbing');
                return;
            }
            if (simState.showRuler && x > simState.ruler.x && x < simState.ruler.x + simState.ruler.width && y > simState.ruler.y && y < simState.ruler.y + simState.ruler.height) {
                simState.ruler.isDragging = true;
                simState.ruler.offsetX = x - simState.ruler.x;
                simState.ruler.offsetY = y - simState.ruler.y;
                canvas.classList.add('move-cursor');
                return;
            }
        }

        function handleMouseMove(e) {
            e.preventDefault();
            const { x, y } = getEventPos(e);

            simState.springs.forEach(s => {
                if (s.isDraggingMass) {
                    const deltaY = y - s.massDrag.startY;
                    s.position = s.massDrag.startPos + deltaY / simState.pixelsPerMeter;
                    s.velocity = 0;
                }
            });

            if (simState.isDraggingRef) {
                simState.movableRefY = y;
            } else if (simState.ruler.isDragging) {
                simState.ruler.x = x - simState.ruler.offsetX;
                simState.ruler.y = y - simState.ruler.offsetY;
            } else {
                updateCursor(x, y);
            }
        }
        
        function handleMouseUp() {
            simState.springs.forEach(s => {
                if (s.isDraggingMass) {
                    setEnergyChartScale();
                }
                s.isDraggingMass = false;
            });
            simState.isDraggingRef = false;
            simState.ruler.isDragging = false;
            canvas.classList.remove('grabbing', 'move-cursor', 'grab-cursor');
        }

        function updateCursor(x, y) {
            let isOverMass = false;
            simState.springs.forEach((s, i) => {
                const massSize = 25 + Math.sqrt(s.mass) * 12;
                const massX_px = (width / (simState.mode + 1)) * (i + 1);
                const massY_px = START_Y + s.position * simState.pixelsPerMeter;

                if (x > massX_px - massSize && x < massX_px + massSize && y > massY_px && y < massY_px + massSize) {
                    isOverMass = true;
                }
            });

            if(isOverMass) {
                canvas.classList.add('grab-cursor');
            } else if (simState.showRuler && x > simState.ruler.x && x < simState.ruler.x + simState.ruler.width && y > simState.ruler.y && y < simState.ruler.y + simState.ruler.height) {
                canvas.classList.add('move-cursor');
            } else {
                canvas.classList.remove('grab-cursor', 'move-cursor');
            }
        }
        
        function resetSimulation() {
            simState.simulationState = 'initial';
            startPauseBtn.textContent = 'Empezar';
            startPauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'bg-blue-600', 'hover:bg-blue-700');
            startPauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            
            simState.springs.forEach(s => {
                const equilibriumPos = getEquilibriumPosition(s);
                s.position = equilibriumPos;
                s.velocity = 0;
                s.acceleration = 0;
                s.potentialGRefY = equilibriumPos; 
                updateEnergy(s);
            });
            
            resetChronometer();
            updateScale();
            setEnergyChartScale();
            updateEnergyGraph();
        }
        
        function fullReset() {
            simState.springs = [];
            for (let i = 0; i < simState.mode; i++) {
                simState.springs.push(createSpringState());
            }
            simState.ruler.x = 100;
            simState.ruler.y = 80;
            generateSpringControls();
            updateChartDataConfig();
            resetSimulation();
        }
        
        function handleStartPause() {
            if (simState.simulationState === 'initial') {
                simState.simulationState = 'running';
                startPauseBtn.textContent = 'Pausar';
                startPauseBtn.classList.replace('bg-green-600', 'bg-yellow-500');
                startPauseBtn.classList.replace('hover:bg-green-700', 'hover:bg-yellow-600');
                setEnergyChartScale();
                resetChronometer();
            } else if (simState.simulationState === 'running') {
                simState.simulationState = 'paused';
                startPauseBtn.textContent = 'Reanudar';
                startPauseBtn.classList.replace('bg-yellow-500', 'bg-blue-600');
                startPauseBtn.classList.replace('hover:bg-yellow-600', 'hover:bg-blue-700');
            } else if (simState.simulationState === 'paused') {
                simState.simulationState = 'running';
                startPauseBtn.textContent = 'Pausar';
                startPauseBtn.classList.replace('bg-blue-600', 'bg-yellow-500');
                startPauseBtn.classList.replace('hover:bg-blue-700', 'hover:bg-yellow-600');
            }
        }
        
        function resetChronometer() {
            simState.chronometerTime = 0;
            simState.springs.forEach(s => {
                s.oscillationCount = 0;
                s.lastPosSign = 0;
            });
        }
        
        function toggleChronometer() {
            simState.chronometerManualPause = !simState.chronometerManualPause;
        }

        // --- PHYSICS, SCALE & ANIMATION ---
        function updateScale() {
            let maxPosition = 0;
            simState.springs.forEach(s => {
                const equilibriumPos = getEquilibriumPosition(s);
                const maxDisplacement = Math.max(Math.abs(s.position - equilibriumPos), Math.abs(s.l0 - equilibriumPos));
                maxPosition = Math.max(maxPosition, s.l0 + maxDisplacement * 2);
            });
            
            const requiredPixels = height - START_Y - 50;
            
            if (maxPosition > 0 && requiredPixels > 0) {
                const requiredPPM = requiredPixels / maxPosition;
                simState.pixelsPerMeter = Math.min(BASE_PIXELS_PER_METER, requiredPPM);
            } else {
                simState.pixelsPerMeter = BASE_PIXELS_PER_METER;
            }
        }

        function updateEnergy(spring) {
            const e = spring.energies;
            e.kinetic = 0.5 * spring.mass * spring.velocity * spring.velocity;
            const elongation = spring.position - spring.l0;
            e.potentialE = 0.5 * spring.k * elongation * elongation;
            const h = -(spring.position - spring.potentialGRefY);
            e.potentialG = spring.mass * simState.gravity * h;
            e.total = e.kinetic + e.potentialE + e.potentialG;
        }

        function setEnergyChartScale() {
            if (!energyChart) return;
            
            let maxBound = 1;
            let minBound = -0.2;

            simState.springs.forEach(s => {
                updateEnergy(s);
                maxBound = Math.max(maxBound, s.energies.total, s.energies.potentialE, 1);
                minBound = Math.min(minBound, s.energies.potentialG);
            });

            // **CORRECCIÓN**: Resetear escalas a null para que Chart.js las recalcule
            energyChart.options.scales.x.min = null;
            energyChart.options.scales.x.max = null;
            energyChart.options.scales.y.min = null;
            energyChart.options.scales.y.max = null;

            if (simState.mode === 1) {
                energyChart.options.scales.x.max = maxBound * 1.2;
                energyChart.options.scales.x.min = minBound * 1.2;
            } else {
                energyChart.options.scales.y.max = maxBound * 1.2;
                energyChart.options.scales.y.min = minBound * 1.2;
            }
            energyChart.update();
        }


        function updatePhysics() {
            if (simState.simulationState !== 'running') return;

            simState.springs.forEach(s => {
                if (s.isDraggingMass) {
                    s.acceleration = 0;
                    s.velocity = 0;
                } else {
                    const elongation = s.position - s.l0;
                    const forceGravity = s.mass * simState.gravity;
                    const forceElastic = -s.k * elongation;
                    const forceDamping = -s.damping * 100 * s.velocity;
                    const totalForce = forceGravity + forceElastic + forceDamping;
                    
                    s.acceleration = totalForce / s.mass;
                    s.velocity += s.acceleration / 60.0;
                    s.position += s.velocity / 60.0;
                }
                updateEnergy(s);
            });

            if (!simState.chronometerManualPause) {
                simState.chronometerTime += 1 / 60.0;
            }
        }

        // --- DRAWING ---
        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            if (simState.showRuler) drawRuler();
            drawReferenceLines();
            if (simState.showChronometer) drawChronometer();
            
            drawSpringSystems();

            if (simState.showEnergyGraph) {
                updateEnergyGraph();
            }
            updatePhysics();
            requestAnimationFrame(draw);
        }

        function drawSpringSystems() {
            let infoHtml = '';
            simState.springs.forEach((s, i) => {
                const startX = (width / (simState.mode + 1)) * (i + 1);
                
                ctx.save();
                ctx.fillStyle = '#9ca3af';
                ctx.font = '16px Inter';
                ctx.textAlign = 'center';
                ctx.fillText((i + 1).toString(), startX, START_Y - 20);
                ctx.restore();

                ctx.fillStyle = '#4b5563';
                ctx.fillRect(startX - 50, START_Y - 10, 100, 10);

                const springLength_px = s.position * simState.pixelsPerMeter;
                drawSpring(startX, START_Y, springLength_px, 25, 15);
                const massY_px = START_Y + springLength_px;
                
                const massColor = i === 0 ? '#3b82f6' : '#f97316';
                drawMass(startX, massY_px, s.mass, massColor);
                
                infoHtml += `<b>Muelle ${i+1}:</b> L=${s.position.toFixed(2)}m, v=${s.velocity.toFixed(2)}m/s<br>`;
                
                if (simState.simulationState !== 'initial') {
                    const Fe = s.k * (s.position - s.l0);
                    if (simState.showForces) {
                        const Fg = s.mass * simState.gravity;
                        drawVector(startX + 40, massY_px, Fg * simState.pixelsPerMeter / 50, '#ef4444', 'Fg');
                        drawVector(startX + 40, massY_px, -Fe * simState.pixelsPerMeter / 50, '#22c55e', 'Fe');
                    }
                    if (simState.showVelocityAccelVectors) {
                        if (Math.abs(s.velocity) > 0.001) drawVector(startX - 40, massY_px, s.velocity * 50, '#06b6d4', 'v');
                        if (Math.abs(s.acceleration) > 0.01) drawVector(startX - 60, massY_px, s.acceleration * 10, '#d946ef', 'a');
                    }
                }
            });
            document.getElementById('info-display-canvas').innerHTML = infoHtml;
            document.getElementById('info-display-panel').innerHTML = infoHtml;
        }
        
        function drawSpring(x, y, length, coils, width) {
            if (length <= 0) return;
            const grad = ctx.createLinearGradient(x - width, y, x + width, y);
            grad.addColorStop(0, '#a0a0a0');
            grad.addColorStop(0.5, '#f0f0f0');
            grad.addColorStop(1, '#a0a0a0');
            
            ctx.save();
            ctx.strokeStyle = grad;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const step = length / coils;
            ctx.beginPath();
            ctx.moveTo(x, y);
            for (let i = 0; i < coils; i++) {
                const y_pos = y + i * step + step / 2;
                const x_offset = (i % 2 === 0) ? width : -width;
                ctx.lineTo(x + x_offset, y_pos);
            }
            ctx.lineTo(x, y + length);
            ctx.stroke();
            ctx.restore();
        }

        function drawMass(x, y, mass, color) {
            const size = 25 + Math.sqrt(mass) * 12;
            
            const grad = ctx.createLinearGradient(x - size / 2, y, x + size / 2, y + size);
            grad.addColorStop(0, lightenColor(color, 20));
            grad.addColorStop(1, color);

            ctx.beginPath();
            ctx.rect(x - size / 2, y, size, size);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = darkenColor(color, 20);
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function lightenColor(hex, percent) {
            hex = hex.replace(/^\s*#|\s*$/g, '');
            if(hex.length == 3){
                hex = hex.replace(/(.)/g, '$1$1');
            }
            var r = parseInt(hex.substr(0, 2), 16),
                g = parseInt(hex.substr(2, 2), 16),
                b = parseInt(hex.substr(4, 2), 16);

            return '#' +
               ((0|(1<<8) + r + (256 - r) * percent / 100).toString(16)).substr(1) +
               ((0|(1<<8) + g + (256 - g) * percent / 100).toString(16)).substr(1) +
               ((0|(1<<8) + b + (256 - b) * percent / 100).toString(16)).substr(1);
        }

        function darkenColor(hex, percent) {
            hex = hex.replace(/^\s*#|\s*$/g, '');
            if(hex.length == 3){
                hex = hex.replace(/(.)/g, '$1$1');
            }
            var r = parseInt(hex.substr(0, 2), 16),
                g = parseInt(hex.substr(2, 2), 16),
                b = parseInt(hex.substr(4, 2), 16);

            return '#' +
               ((0|(1<<8) + r * (100 - percent) / 100).toString(16)).substr(1) +
               ((0|(1<<8) + g * (100 - percent) / 100).toString(16)).substr(1) +
               ((0|(1<<8) + b * (100 - percent) / 100).toString(16)).substr(1);
        }


        function drawVector(startX, startY, value, color, label) {
            const arrowLength = value;
            const endY = startY + arrowLength;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();

            const headlen = 10;
            ctx.beginPath();
            ctx.moveTo(startX, endY);
            ctx.lineTo(startX - headlen / 2, endY - Math.sign(arrowLength) * headlen);
            ctx.lineTo(startX + headlen / 2, endY - Math.sign(arrowLength) * headlen);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();

            ctx.fillStyle = color;
            ctx.font = '12px Inter';
            ctx.textAlign = 'left';
            ctx.fillText(label, startX + 5, startY + arrowLength / 2);
        }

        function drawReferenceLines() {
            if (simState.springs.length === 0) return;

            if (simState.showNaturalLength) {
                const y = START_Y + simState.springs[0].l0 * simState.pixelsPerMeter;
                drawDashedLine(0, y, width, y, '#f97316', 'L₀');
            }
            if (simState.showEquilibrium) {
                const equilibriumPos = getEquilibriumPosition(simState.springs[0]);
                const y = START_Y + equilibriumPos * simState.pixelsPerMeter;
                drawDashedLine(0, y, width, y, '#22c55e', 'Eq');
            }
            if (simState.showMovableRef) {
                drawDashedLine(0, simState.movableRefY, width, simState.movableRefY, '#a855f7', 'Ref');
            }
        }
        
        function drawDashedLine(x1, y1, x2, y2, color, label) {
            ctx.save();
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            ctx.fillStyle = color;
            ctx.font = '12px Inter';
            ctx.textAlign = 'left';
            ctx.fillText(label, 10, y1 - 5);
        }

        function drawRuler() {
            const r = simState.ruler;
            const ppm = simState.pixelsPerMeter;
            ctx.save();
            ctx.fillStyle = 'rgba(229, 231, 235, 0.2)';
            ctx.strokeStyle = 'rgba(156, 163, 175, 0.5)';
            ctx.lineWidth = 1;
            ctx.fillRect(r.x, r.y, r.width, r.height);
            ctx.strokeRect(r.x, r.y, r.width, r.height);

            ctx.strokeStyle = '#d1d5db';
            ctx.fillStyle = '#d1d5db';
            ctx.font = '10px Inter';
            ctx.textAlign = 'right';

            const minPixelStep = 20;
            const minMeterStep = minPixelStep / ppm;
            const niceSteps = [0.1, 0.2, 0.5, 1, 2, 5];
            const meterStep = niceSteps.find(step => step >= minMeterStep) || 5;

            const rulerStartInMeters = (r.y - START_Y) / ppm;
            const firstTickInMeters = Math.ceil(rulerStartInMeters / meterStep) * meterStep;

            for (let m = firstTickInMeters; ; m += meterStep) {
                const y = START_Y + m * ppm;
                if (y > r.y + r.height) break;
                if (y < r.y) continue;
                
                const tickLength = 25;
                const label = m < 1 ? `${(m*100).toFixed(0)} cm` : `${m.toFixed(1)} m`;
                ctx.fillText(label, r.x + r.width - tickLength - 5, y + 3);
                ctx.beginPath();
                ctx.moveTo(r.x + r.width, y);
                ctx.lineTo(r.x + r.width - tickLength, y);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        function drawChronometer() {
            chronoTimeEl.textContent = `${simState.chronometerTime.toFixed(1)}s`;
            iconPause.classList.toggle('hidden', simState.chronometerManualPause);
            iconPlay.classList.toggle('hidden', !simState.chronometerManualPause);
        }

        function updateEnergyGraph() {
            if (!energyChart) return;
            if(simState.mode === 1) {
                const e = simState.springs[0].energies;
                energyChart.data.datasets[0].data = [e.kinetic, e.potentialE, e.potentialG, e.total];
            } else {
                simState.springs.forEach((s, i) => {
                    const e = s.energies;
                    energyChart.data.datasets[i].data = [e.kinetic, e.potentialE, e.potentialG, e.total];
                });
            }
            energyChart.update('none');
        }

        function setupChartDrag() {
            const chartHeader = document.querySelector('.chart-header');
            let isDragging = false;
            let offsetX, offsetY;

            function onMouseDown(e) {
                if (window.innerWidth < 769) return;
                isDragging = true;
                const eventPos = e.touches ? e.touches[0] : e;
                const rect = energyChartOverlay.getBoundingClientRect();
                offsetX = eventPos.clientX - rect.left;
                offsetY = eventPos.clientY - rect.top;
                
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
                window.addEventListener('touchmove', onMouseMove, { passive: false });
                window.addEventListener('touchend', onMouseUp);
            }

            function onMouseMove(e) {
                if (!isDragging) return;
                e.preventDefault();
                const eventPos = e.touches ? e.touches[0] : e;
                let newLeft = eventPos.clientX - offsetX;
                let newTop = eventPos.clientY - offsetY;

                const parentRect = document.querySelector('.main-container').getBoundingClientRect();
                newLeft = Math.max(0, Math.min(newLeft, parentRect.width - energyChartOverlay.offsetWidth));
                newTop = Math.max(0, Math.min(newTop, parentRect.height - energyChartOverlay.offsetHeight));

                energyChartOverlay.style.left = `${newLeft}px`;
                energyChartOverlay.style.top = `${newTop}px`;
                energyChartOverlay.style.bottom = 'auto';
                energyChartOverlay.style.right = 'auto';
            }

            function onMouseUp() {
                isDragging = false;
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
                window.removeEventListener('touchmove', onMouseMove);
                window.removeEventListener('touchend', onMouseUp);
            }

            chartHeader.addEventListener('mousedown', onMouseDown);
            chartHeader.addEventListener('touchstart', onMouseDown, { passive: false });
        }


        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            startPauseBtn = document.getElementById('start-pause-btn');
            resetSimulationBtn = document.getElementById('reset-simulation-btn');
            chronoContainer = document.getElementById('chronometer-container');
            chronoTimeEl = document.getElementById('chronometer-time');
            chronoPausePlayBtn = document.getElementById('chrono-pause-play-btn');
            chronoResetBtn = document.getElementById('chrono-reset-btn');
            iconPause = document.getElementById('icon-pause');
            iconPlay = document.getElementById('icon-play');
            energyChartOverlay = document.getElementById('energy-chart-overlay');
            simModeSelect = document.getElementById('sim-mode');
            springsControlsContainer = document.getElementById('springs-controls-container');
            globalControlsContainer = document.getElementById('global-controls-container');


            resizeCanvas();
            initEnergyChart();
            setupEventListeners();
            fullReset();
            
            if (simState.showEnergyGraph) {
                energyChartOverlay.classList.remove('hidden');
            }

            draw();
        });

    </script>
</body>
</html>
